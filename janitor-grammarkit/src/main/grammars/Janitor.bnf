// BNF grammar for Janitor language,
// based on janitor-lang/src/main/antlr4/com/eischet/janitor/lang/Janitor.g4
// for use with JetBrains Grammar-Kit.

{
  // Define token types
  tokens=[
    FUNCTION="function",
    BREAK="break",
    CATCH="catch",
    CONTINUE="continue",
    DO="do",
    ELSE="else",
    FINALLY="finally",
    FOR="for",
    IF="if",
    THEN="then",
    IMPORT="import",
    RETURN="return",
    THROW="throw",
    TRY="try",
    WHILE="while",
    TRUE="true",
    FALSE="false",
    NULL="null",
    FROM="from",
    TO="to",
    IN="in",
    DECIMAL_LITERAL="(0|[1-9][0-9_]*)([lL])?",
    HEX_LITERAL="0[xX][0-9a-fA-F][0-9a-fA-F_]*([lL])?",
    OCT_LITERAL="0_*[0-7][0-7_]*([lL])?",
    BINARY_LITERAL="0[bB][01][01_]*([lL])?",
    FLOAT_LITERAL="([0-9]+\\.[0-9]*|\\.[0-9]+)([eE][+-]?[0-9]+)?[fFdD]?|[0-9]+([eE][+-]?[0-9]+[fFdD]?|[fFdD])",
    DATE_LITERAL="@-?[0-9]{4}-[0-9]?[0-9]-[0-9]?[0-9]",
    DATE_TIME_LITERAL="@-?[0-9]{4}-[0-9]?[0-9]-[0-9]?[0-9]-[0-9]?[0-9]:[0-9]{2}(:[0-9]{2})?",
    YEARS_LITERAL="@[0-9]+y",
    MONTHS_LITERAL="@[0-9]+mo",
    WEEKS_LITERAL="@[0-9]+w",
    DAYS_LITERAL="@[0-9]+d",
    HOURS_LITERAL="@[0-9]+h",
    MINUTES_LITERAL="@[0-9]+mi",
    SECONDS_LITERAL="@[0-9]+s",
    TODAY_LITERAL="@today",
    NOW_LITERAL="@now",
    STRING_LITERAL_SINGLE="'([^'\\\\\\r\\n]|\\\\.)*'",
    STRING_LITERAL_DOUBLE="\"([^\"\\\\\\r\\n]|\\\\.)*\"",
    STRING_LITERAL_TRIPLE_SINGLE="'''([^\\\\]|\\\\.)*?'''",
    STRING_LITERAL_TRIPLE_DOUBLE="\"\"\"([^\\\\]|\\\\.)*?\"\"\"",
    REGEX_LITERAL="re/([^/\\\\\\r\\n]|\\\\.)*/",
    LPAREN="\\(",
    RPAREN="\\)",
    LBRACE="\\{",
    RBRACE="\\}",
    LBRACK="\\[",
    RBRACK="\\]",
    SEMICOLON=";",
    COMMA=",",
    DOUBLE_DOT="..",
    DOT=".",
    QDOT="\\?.",
    ASSIGN="=",
    PLUS_ASSIGN="\\+=",
    MINUS_ASSIGN="-=",
    MUL_ASSIGN="\\*=",
    DIV_ASSIGN="/=",
    MOD_ASSIGN="%=",
    GT=">",
    LT="<",
    MATCH="~",
    MATCH_NOT="!~",
    QUESTION="\\?",
    COLON=":",
    EQUAL="==",
    LE="<=",
    GE=">=",
    NOTEQUAL="!=",
    ALT_NOTEQUAL="<>",
    NOT="not",
    ALT_NOT="!",
    AND="and",
    CAND="&&",
    OR="or",
    COR="\\|\\|",
    INC="\\+\\+",
    DEC="--",
    ADD="\\+",
    SUB="-",
    MUL="\\*",
    DOUBLE_STAR="\\*\\*",
    DIV="/",
    MOD="%",
    ARROW="->",
    COMMENT="/\\*[^*]*\\*+(?:[^/*][^*]*\\*+)*/",
    LINE_COMMENT="//[^\\r\\n]*",
    NEWLINE="[\\r\\n]+",
    IDENTIFIER="[a-zA-Z$_][a-zA-Z0-9$_]*"
  ]
}

script ::= topLevelStatement*;

stmtTerminator ::= SEMICOLON | NEWLINE;

topLevelStatement ::= importStatement | blockStatement;

importStatement ::= IMPORT importClause (COMMA importClause)* stmtTerminator;

importClause ::= qualifiedName ('as' importAlias)?
               | STRING_LITERAL_SINGLE 'as' importAlias
               | STRING_LITERAL_DOUBLE 'as' importAlias;

blockStatement ::= block
                 | ifStatementDef
                 | FOR LPAREN validIdentifier IN expression RPAREN block
                 | FOR LPAREN validIdentifier FROM expression TO expression RPAREN block
                 | WHILE LPAREN expression RPAREN block
                 | DO block WHILE LPAREN expression RPAREN stmtTerminator
                 | TRY block (catchClause? finallyBlock? | finallyBlock)
                 | RETURN expression? stmtTerminator
                 | THROW expression stmtTerminator
                 | BREAK stmtTerminator
                 | CONTINUE stmtTerminator
                 | expression (ASSIGN | PLUS_ASSIGN | MINUS_ASSIGN | MUL_ASSIGN | DIV_ASSIGN | MOD_ASSIGN) expression
                 | expression stmtTerminator
                 | functionDeclaration
                 | SEMICOLON;

ifStatementDef ::= IF LPAREN expression RPAREN block (ELSE block | ELSE ifStatementDef)?;

block ::= LBRACE blockStatement* RBRACE;

expression ::= expression DOT validIdentifier LPAREN argumentList? RPAREN
             | expression QDOT validIdentifier LPAREN argumentList? RPAREN
             | expression DOT validIdentifier
             | expression QDOT validIdentifier
             | functionCall
             | expression (DOT | QDOT) (validIdentifier | functionCall | explicitGenericInvocation)
             | LPAREN expression RPAREN
             | DECIMAL_LITERAL
             | HEX_LITERAL
             | BINARY_LITERAL
             | FLOAT_LITERAL
             | YEARS_LITERAL
             | MONTHS_LITERAL
             | DAYS_LITERAL
             | WEEKS_LITERAL
             | HOURS_LITERAL
             | MINUTES_LITERAL
             | SECONDS_LITERAL
             | DATE_TIME_LITERAL
             | NOW_LITERAL
             | DATE_LITERAL
             | TODAY_LITERAL
             | STRING_LITERAL_TRIPLE_SINGLE
             | STRING_LITERAL_TRIPLE_DOUBLE
             | STRING_LITERAL_SINGLE
             | STRING_LITERAL_DOUBLE
             | REGEX_LITERAL
             | TRUE
             | FALSE
             | NULL
             | validIdentifier
             | explicitGenericInvocationSuffix
             | expression LBRACK expression? COLON expression? COLON expression RBRACK
             | expression LBRACK expression COLON RBRACK
             | expression LBRACK COLON expression RBRACK
             | expression LBRACK expression COLON expression RBRACK
             | expression LBRACK COLON RBRACK
             | expression LBRACK expression RBRACK
             | expression (INC | DEC)
             | (ADD | SUB | INC | DEC) expression
             | (NOT | ALT_NOT) expression
             | expression (MUL | DIV | MOD) expression
             | expression (ADD | SUB) expression
             | expression (LE | GE | GT | LT) expression
             | expression (EQUAL | NOTEQUAL | ALT_NOTEQUAL | MATCH | MATCH_NOT) expression
             | expression (AND | CAND) expression
             | expression (OR | COR) expression
             | expression QUESTION expression COLON expression
             | lambdaParameters ARROW lambdaBody
             | IF expression THEN expression (ELSE expression)?
             | LBRACE (propertyAssignment (COMMA propertyAssignment)* COMMA?)? RBRACE
             | LBRACK (expression (COMMA expression)* COMMA?)? RBRACK;

validIdentifier ::= IDENTIFIER | FROM | TO | IN;

propertyAssignment ::= (STRING_LITERAL_TRIPLE_DOUBLE | STRING_LITERAL_TRIPLE_SINGLE | STRING_LITERAL_DOUBLE | STRING_LITERAL_SINGLE | validIdentifier) COLON expression;

functionDeclaration ::= FUNCTION validIdentifier formalParameters block;

formalParameters ::= LPAREN formalParameterList? RPAREN;

formalParameterList ::= (nonDefaultParamList COMMA)? defaultParamList (COMMA varArgList)? (COMMA kwArgList)?
                      | nonDefaultParamList (COMMA varArgList)? (COMMA kwArgList)?
                      | varArgList (COMMA kwArgList)?
                      | kwArgList;

nonDefaultParamList ::= formalParameter (COMMA formalParameter)*;

defaultParamList ::= formalParameterWithDefault (COMMA formalParameterWithDefault)*;

varArgList ::= MUL validIdentifier;

kwArgList ::= DOUBLE_STAR validIdentifier;

formalParameter ::= validIdentifier;

formalParameterWithDefault ::= validIdentifier ASSIGN expression;

importAlias ::= validIdentifier;

qualifiedName ::= validIdentifier (DOT validIdentifier)*;

catchClause ::= CATCH LPAREN validIdentifier RPAREN block;

finallyBlock ::= FINALLY block;

argumentList ::= positionalArgs (COMMA keywordArgs)?
               | keywordArgs;

positionalArgs ::= argument (COMMA argument)*;

keywordArgs ::= keywordArg (COMMA keywordArg)*;

argument ::= expression;

keywordArg ::= validIdentifier ASSIGN expression;

functionCall ::= validIdentifier LPAREN argumentList? RPAREN;

lambdaParameters ::= validIdentifier
                   | LPAREN formalParameterList? RPAREN
                   | LPAREN validIdentifier (COMMA validIdentifier)* RPAREN;

lambdaBody ::= expression | block;

explicitGenericInvocation ::= explicitGenericInvocationSuffix;

explicitGenericInvocationSuffix ::= validIdentifier arguments;

arguments ::= LPAREN argumentList? RPAREN;
